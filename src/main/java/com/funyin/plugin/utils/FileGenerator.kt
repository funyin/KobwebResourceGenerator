package com.funyin.plugin.utils

import com.funyin.plugin.utils.PluginUtils.showNotify
import com.funyin.plugin.utils.PluginUtils.toLowCamelCase
import com.funyin.plugin.utils.PluginUtils.upperCaseFirst
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.project.guessModuleDir
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiManager

class FileGenerator(private val project: Project) {
    private val ignoreDir = listOf("2.0x", "3.0x", "Mx", "Nx")

    /**
     * 为所有模块重新生成
     */
    fun generateAll() {
        WriteCommandAction.runWriteCommandAction(project) {
            val assets = FileHelperNew.getResources(project) as MutableList
            assets.removeAll {
                println("module : ${it.module} resources ${it.assetVFiles}")
                it.assetVFiles.isEmpty()
            }
            if (assets.isEmpty()) {
                showNotify("Please configure your resources path in pubspec.yaml")
                return@runWriteCommandAction
            }
            for (config in assets) {
                generateWithConfig(config)
            }
        }
    }


    /**
     * 生成单个模块文件
     */
    fun generateOne(config: ModuleGradleConfig) {
        WriteCommandAction.runWriteCommandAction(project) {
            generateWithConfig(config)
        }
    }

    private fun generateWithConfig(config: ModuleGradleConfig) {
        println(config)
        val module = config.module
        val map = mutableMapOf<String, String>()
        val ignorePath = FileHelperNew.getPathIgnore(config)
        // 这里可能有多个目录或者文件
        for (file in config.assetVFiles) {
            println("generate file map in $file")
            generateFileMap(
                file,
                config,
                map,
                ignorePath,
            )
        }
        if (map.isEmpty()) {
//            showNotify("assets path is empty")
            println("${config.module} resources map is empty, skip")
            return
        }
        val content = StringBuilder()
        content.append("///This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n")
        val className = FileHelperNew.getGeneratedClassName(config)
        content.append("object $className {\n ")
        map.toSortedMap().forEach {
            content.append("  val ${it.key}:String = '${it.value}';\n")
        }
        content.append("\n}\n")
        val psiManager = PsiManager.getInstance(project)
        val psiDocumentManager = PsiDocumentManager.getInstance(project)
        FileHelperNew.getGeneratedFile(config).let { generated ->
            psiManager.findFile(generated)?.let { dartFile ->
                psiDocumentManager.getDocument(dartFile)?.let { document ->
                    if (document.text != content.toString()) {
                        document.setText(content)
                        psiDocumentManager.commitDocument(document)
                        showNotify("$module : resources generate succeed")
                    } else {
                        showNotify("$module : nothing changed")
                    }
                }
            }
        }
    }

    private fun generateFileMap(
        root: VirtualFile,
        config: ModuleGradleConfig,
        map: MutableMap<String, String>,
        ignorePath: List<String>,
    ) {
        val namedWithParent = FileHelperNew.isNamedWithParent(config)
        val pattern = FileHelperNew.getFilenameSplitPattern(config)
        val basePath = config.module.guessModuleDir()?.path
        val regex = Regex(pattern)
        if (root.isDirectory) {
            root.children.filter {
                var pathIgnore = false
                if (ignorePath.isNotEmpty()) {
                    for (name in ignorePath) {
                        if (it.path.contains(name, ignoreCase = true)) {
                            pathIgnore = true
                            println("${it.path} pathIgnore : $pathIgnore")
                            break
                        }
                    }
                }
                !it.name.startsWith('.') && checkName(it.name) && !pathIgnore
            }.forEach {
                if (it.isDirectory) {
                    generateFileMap(it, config, map, ignorePath)
                } else {
                    config(it, regex, basePath, namedWithParent, map)
                }
            }
        } else {
            config(root, regex, basePath, namedWithParent, map)
        }
    }

    private fun config(
        it: VirtualFile,
        regex: Regex,
        basePath: String?,
        namedWithParent: Boolean,
        map: MutableMap<String, String>
    ) {
        var key = it.nameWithoutExtension.replace(".", "_").toLowCamelCase(regex)///fileName style
        val value = it.path.removePrefix("$basePath/")
        if (namedWithParent) {
            it.parent?.let { parent ->
                key = "${parent.name.toLowCamelCase(regex)}${key.upperCaseFirst()}"
                if (map.containsKey(key)) {
                    key = "${parent.parent.name.toLowCamelCase(regex)}${key.upperCaseFirst()}"
                }
                map[key] = value
            }
        } else {
            map[key] = value
        }
    }

    private fun checkName(name: String): Boolean {
        return !ignoreDir.contains(name)
    }

}
